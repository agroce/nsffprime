While automated test generation by fuzzing or binary-level symbolic execution can be highly effective as a means for finding bugs in code, other approaches are also needed to handle the kinds of code especially common in embedded contexts.  In particular, embedded software often includes a large number of functions that perform complex low-level bit operations, especially for interacting with hardware and ``parsing'' network packets (from traditional wireless or RF-derived signals).  Fuzzing or binary symbolic analysis often has trouble  finding exact bit-values; it is well known that, e.g., inverting even non-cryptographic hashes is hard.  Translation to SAT or SMT, however, often easily handles such problems.

CBMC, the C Bounded Model Checker~\cite{cbmcp} is a well-known tool that analyzes C and C++ programs using a translation to SAT or SMT queries based on a bounded unrolling of loops. CBMC is an actively developed project, and has been used extensively in real-world development for years, including in automotive/embedded code development at Bosch and General Electric~\cite{tiemeyer2019crest}, in analysis of Amazon Web Services infrastructure~\cite{awsmodel}, and in the analysis of flight software systems at NASA's Jet Propulsion Laboratory~\cite{AMAI}, including by PI Groce.  Using CBMC requires writing custom test harnesses using CBMC's API for expressing nondeterminism, and running the tool with a specified bound on loop executions, in addition to other complex configuration options.

We propose to allow CBMC to be used as a backend for verification by DeepState, with a seamless interface, just as DeepState currently supports symbolic analysis engines such as angr and Manticore.  It is notoriously hard to guess when a SAT/SMT based approach to code analysis will work well and when it will fail to scale; using a DeepState harness will allow users to try CBMC at ``no cost.''  This means that the methods used to construct DeepState harnesses for FPrime-based code will automatically be applicable to using CBMC to model check critical parts of an FPrime system.  In particular, bounded model checkers excel at finding extremely subtle errors in the kinds of bit-manipulation used in transforming data read from hardware sensors into meaningful value in physical units, found in many embedded systems.  Because the ESBMC model checker~\cite{ESBMC} is derived from CBMC, and in some cases may be more effective for analyzing C++ code, it should be possible to extend the CBMC-interface for DeepState to also work with ESBMC, either via a common harness generation with wrappers for differences, or via two harness generation implementations using a shared algorithm (since the core transforms needed are semantically very similar).

Moreover, because choosing loop unwinding bounds imposes a serious burden on embedded engineers, we will investigate their automatic determinations.  Embedded software is more likely than most code to make use of explicit, well-defined loop bounds, especially in cases where a loop is interacting with real-time guarantees.  When this does not hold, or the bound determined from embedded or real-time constraints is still far too large, another approach is to instrument fuzzer or symbolic-execution engine generated tests to record iterations of loops, and then use the maximum bound observed.  Additionally, for small functions (the most likely targets for DeepState-CBMC: complex but compact bit-manipulation code), the mutation-based approach proposed by Groce et. al~\cite{groce2018verified} may work.  Finally, in some cases CBMC may be able to find interesting bugs for cases where the loop unrollings are limited, but cannot scale to larger depth limits.  Using the same instrumentation that we use to estimate loop bounds, we will use the ability to guide fuzzers by alternative ``coverage'' to focus fuzzer runs on executions with more loop iterations than the bound explored by CBMC.  This will offer engineers a true partnership between verification methods.