\section{Problem Statement, Overview, and Objectives}

%\subsection{Problem Statement}
%\input{problem}

Developing complex embedded systems software has always posed unusual
challenges:  because such systems tend to directly impact the physical
world, they often have stringent correctness requirements.
Conventional software often has the recourse to ``restore to backup''
or simply reboot; embedded systems software that interacts with
actuators in addition to sensors constantly faces the problem of
irrevocable damage to physical systems for which no backup is
possible.  In the extreme case, such as an embedded system operating
on a probe orbiting Saturn or a rover on Mars, even post-mortem
analysis, much less diagnosis and repair, may be impossible after a
catastrophic software error.

On the other hand, such systems often face limitations in terms of
resources:  hardware, not software, development is often the core
concern of an embedded systems project.  The exact portion of the NASA
Curiosity Mars Rover budget devoted to software is difficult to
ascertain, but it certainly amounts to less than 25\% of the total
Rover budget, despite being a monumental software
project~\cite{NASAbudget}.  The actual likely value is somewhere below
10\%, since the 25\% figure includes all R\&D, design, and spacecraft
construction costs.

Building software with extremely rigorous correctness requirements,
often under tight budget constraints relative to total project budget,
and almost always in low-level languages, using error-prone memory
allocation methods, where concurrency with real-time constraints is
also almost always involved, poses a serious challenge indeed.

One way embedded developers meet such challenges is by making use of
\emph{embedded systems development frameworks:} collections of tools,
libraries, and processes that streamline the creation of software for
embedded devices.  Just as web developers make use of web development
frameworks, embedded developers make use of pre-built functionality beyond the capabilities provided
by C and C++ standard libraries and conventional real-time operating
systems such as VxWorks, in the form of systems that constrain but ease
development of the kinds of systems they build.  A key difference
between, e.g., web development frameworks and embedded systems
frameworks, however, is that some of the most prominent embedded
frameworks have a major focus on correctness and reliability, rather
than simply ease of development.  The high cost of embedded failures
is to some extent represented in the nature of embedded frameworks.

However, by and large, this focus on specification, correctness, and
reliability is not connected to state-of-the-art testing methods.
Embedded systems failures due to very rare circumstances can be
catastrophic, but widely-used embedded systems frameworks do not
facilitate testing beyond standard manual unit and integration
testing methods.  Particularly in concurrent software, or software
involving manipulation of bit-level data, however, human ingenuity is
hard-pressed to explore the variety of inputs and hardware failure scenarios that
embedded systems must handle.

Modern test generation techniques,
particularly fuzzing, but also including symbolic/concolic execution
and model checking, are natural fits for these kinds of
(semi-)exhaustive input explorations, but are 1) not part of the
reportoire of most embedded systems developers or test engineers and
2) not always easily adaptable to embedded contexts.  This project
aims to address this problem by  developing methods and tools for
\emph{framework-aware fuzzing and lightweight verification}, using
NASA's FPrime embedded development framework as a central testbed.
The approach proposed exploits framework-provided constraints and type
information to generate test harnesses and guide \emph{semantic-aware
  fuzzing}. With \textbf{DeepState} as the primary interface and
exploratory integration with C++-capable model checkers, this project combines fuzzing with verification to explore \emph{meaningful} behaviors automatically. Framework metadata provides semantic constraints that focus fuzzers on valid inputs; when data violates preconditions, \emph{precondition mapping} transforms it into satisfying assignments.
The work also introduces \emph{framework-customized mutation testing},
defining operators aligned with FPrime’s architecture to guide and
evaluate testing. Methods will be demonstrated on real FPrime deployments
and generalized to other frameworks.   The end-goal of this project is
to allow embedded systems developers to employ state-of-the-art
methods for finding bugs in software systems, in ways that
automatically leverage the additional information provided by the use
of embedded systems frameworks, while remaining within the paradigms
and development practices with which they are familliar.  This is part
of a larger picture of making \emph{advanced software correctness
  technologies} available to developers who are not software testing
or verification experts, in a form that combines a \emph{lower cost of
  adoption} with a \emph{higher benefit for adoption}.

\subsection{NASA's FPrime Framework}

NASA’s FPrime (F')~\cite{fprime,fprimerepo} is a component-oriented,
model-driven embedded systems framework originally developed at the
Jet Propulsion Laboratory and now widely adopted across NASA missions
and by external research groups.  FPrime is not a research project; it
has been deployed on multiple real missions, including, most notably,
for the Ingenuity Mars helicoper project~\cite{jpl_ingenuity_fprime}.

An FPrime project is structured
around a set of independently developed C++ components that
communicate through typed \emph{ports} (synchronous function-call
ports or asynchronous message-based ports) combined into a specific deployment through an explicit \emph{topology}. The \emph{F Prime Modeling Language} (FPP)~\cite{FPP} further raises the level of abstraction: developers describe components, port signatures, parameter types, command and telemetry dictionaries, and system topologies in a concise declarative language, from which FPrime’s code generators produce the corresponding C++ scaffolding, XML artifacts, and ground data dictionaries. This modeling layer captures a rich set of semantic constraints that govern legal interactions between components, the structure of messages exchanged at runtime, and the configuration of queues, priorities, and initialization sequences.

Although originally motivated by software reuse, portability, and
mission robustness, the FPrime architecture inadvertently provides
exactly the kind of metadata that modern automated test generation
systems require but usually lack. Typed port definitions, enumerated
dictionaries, deployment wiring, and initialization constraints define
a semantic boundary around each component and the system as a
whole. These boundaries serve as \emph{implicit specifications}: they
tell developers which values are meaningful, which message sequences
can occur, and which invariants must hold across components, and often
(albeit often implicitly) which memory locations a module or function may
legitimately read or modify. Presently, however, these semantics play almost no role in validation; FPrime projects typically employ only manually written unit tests and hand-coded integration scenarios. Existing fuzzers and model checkers treat the generated C++ as an unstructured program, ignoring the framework-level information that could guide input construction and drastically reduce the search space of tests.

This project directly addresses this gap. By extracting the semantic
structure encoded in FPrime’s modeling and code-generation pipeline
(port types, parameter ranges, connection graphs, command/telemetry
interfaces, and configuration metadata) we can automatically generate
harnesses that instantiate real FPrime deployments under test and feed
them with structured, type-correct inputs. These same semantics guide
\emph{semantic-aware fuzzing}: fuzzers such as DeepState become
framework-informed, able to focus on inputs that satisfy port
preconditions or, when random data violates those preconditions,
transform such data into valid assignments through \emph{precondition
  mapping}. FPrime’s architecture similarly enables
\emph{framework-customized mutation testing}: by defining mutation
operators at the model and component-interface levels, focusing on
altered port connections, modified queue depths or policies, and
perturbed command dictionarie, we can create realistic, framework-relevant mutants that measure the adequacy of both developer-written and automatically generated tests.

FPrime thus offers a uniquely suitable foundation for this research: it is modern, actively maintained, mission-proven, and explicitly structured around metadata that can drive automated assurance. By making fuzzing, model checking, and mutation testing sensitive to FPrime’s semantics, we not only improve reliability for missions already depending on FPrime but also establish a general methodology applicable to other embedded systems frameworks. The techniques developed in this project aim to integrate seamlessly into FPrime’s existing workflow, allowing developers to adopt advanced testing and verification methods without leaving the framework ecosystem that already shapes how they design, build, and deploy embedded software.

\section{Intellectual Merit}
\input{merit}